# 第十七章-内存中的缓存池Buffer Pool

> 

## 缓存的重要性

​	如果要访问某个页面的数据，即使是一个页面中的一条数据，也需要先把整个页的数据加载到内存中，然后再进行读写访问，而且再读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来。这样将来有请求在此访问该页面时，就可以省下磁盘IO的开销。

## InnoDB的Buffer Pool

### 什么是Buffer Pool

​	为了缓存磁盘中的页，设计MySQL的大叔在MySQL服务器启动时就向操作系统申请了一片连续的内存，即Buffer Pool，默认设置只有128MB，可以在启动配置项中修改`innodb_buffer_pool_size`选项修改对应的大小

## Buffer Pool内部组成

​	Buffer Pool对应的一片连续的内存区域被划分为若干个页面以及对应的若干个控制块，页面大小与表空间中的页面大小一致，都为16KB，在Buffer Pool中的页被称为**缓冲页**，控制块中的控制信息包括该页所需的表空间编号、页号、缓冲页在Buffer Pool中的地址、链表节点信息等。

​	每个缓冲页对应的控制块占用的内存大小是相同的，控制块放在Buffer Pool的前面，缓冲页放在Buffer Pool的后面

![](D:\Program Files\电子书\go\md\图片\image-20221228130017372.png)

## Buffer Pool的多种链表管理

### Free链表

​	把所有空闲的缓冲页对应的控制块作为一个节点放到一个链表中，这个链表就称为free链表；每当需要从磁盘中加载一个页到Buffer Pool中时，就从free链表中取一个空闲的缓冲页，并且把该缓冲页对应的控制块的信息填上，然后就把该缓冲页对应的free链表节点从链表中移除，表示该缓冲页已经被使用了

![](D:\Program Files\电子书\go\md\图片\image-20221228130255552.png)

### Flush链表

​	修改了某个缓冲页的数据以后，它就与磁盘上的页不一致了，这样的缓冲页称为**脏页**，频繁地往磁盘中写入脏页会影响程序的性能，所以每次修改缓冲页以后，都是在未来的某个时间点进行刷新；因此创建一个链表来存储累计的脏页，其控制块都会作为节点加入到该链表中。

![](D:\Program Files\电子书\go\md\图片\image-20221228130715864.png)

### LRU链表

​	当Buffer Pool中不再有空闲的缓冲页时，就需要淘汰掉最近很少使用的部分缓冲页，如何知道那些缓冲页最近频繁使用，哪些最近很少使用呢? 当需要访问某个页面时，可以按照下面的方式处理LRU链表

 - 该页不在Buffer Pool中，就把该页从磁盘加载到Buffer Pool中的缓冲页时，就把该缓冲页对应控制块作为节点加入到LRU链表的头部
 - 该页在Buffer Pool中，直接把该页对应的控制块移动到LRU链表的头部

​	我们还需要对LRU链表划分区域，因为预读以及全表扫描的一些情况的出现，会降低Buffer Pool的命中率，因此将LRU链表按照一定比例分为`young`区域和`old`区域，`young`区域是热数据区域，`old`区域是冷数据区域，可以通过`innodb_old_blocks_pct`系统变量来调节old区域的比例

![](D:\Program Files\电子书\go\md\图片\image-20221228131646396.png)

