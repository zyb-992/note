# 微服务设计

![](https://raw.githubusercontent.com/zyb-992/Photobed/master/zyb/202304160233186.jpg)

## 定义微服务

> **Martin Fowler** : The microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API.



​	Martin Fowler与James Lewis共同提出微服务的概念，Martin Fowler指出微服务架构是一种将单体应用开发成一系列微型服务的组合，每个服务都运行他们各自的程序，服务间通常使用像HTTP的API资源来进行轻量通信。



​	应用程序除了单体架构以外还有逐步演进的微服务架构，单体架构的所有功能都编写在一个代码库中，使得耦合度高，导致修改代码时开发人员的效率较低；同时在对某个功能进行修改删除或新增功能时，程序都需要重新构建编译后经过测试再发布运行，由于单体代码结构巨大导致编译时长太久，部署成本较高，效率较低。



​	`SOA`(Service Oriented Architecture)——面向服务架构，开发人员将代码根据业务拆分成不同的功能单元，即**服务**；使用服务来拆解单体架构，降低代码的耦合度，而服务的定义：**每个服务就是一个实现了相应功能的单元**；大型项目都渐渐从单体架构走向了微服务架构。



​	*微服务是SOA的一种架构形式*，微服务架构是由不同的开发团队编写的服务之间协助运行；服务之间秉承**高内聚 松耦合**，各个服务之间通过预定义好的API进行通信，服务间通过通信协议联系在一起，各个服务由开发团队自主维护与测试，提高了自治性；应用定义了程序的进入端点，客户端进入后上游会根据请求调用相应的下游服务，形成一系列链路调用；大多数项目使用微服务架构时，通常是一个服务对应一个服务器，现如今容器的流行，例如Docker，由于Docker的隔离性(使用了Linux中的`Cgroup`，`namespace`的特性)，一个运行中的容器可以看作一个被隔离的进程，使得一台主机上可以运行多个容器，而每个容器对应于一个服务。





## 微服务的特点

- 自治性强

  - 不同开发团队编写各自的服务，同时编写各自服务的测试与进行相应的部署，团队为服务的整个生命周期负责

    

- 高内聚 松耦合

  - 定义了服务的边界，除必须公开绝对必要的信息外几乎不对外提供内部信息

  - 服务是可更改和可独立部署的，而不需要更改系统的其他部分

  - 程序中服务的所有逻辑都汇聚在一个地方，实现了高内聚

    

- 程序伸缩性强 易扩展

  - 修改服务时仅需修改该服务的部分代码，而不会影响到全局其他功能的使用，同时也可以基于目前的服务为服务进行相应的扩展

    

- 容错率高

  - 服务所在服务器宕机时不会影响其他服务，接口根据响应时间来判断服务是否存活，同时可以根据集群服务来实现服务高可用

    

- 提高开发效率

  - 通过CI/CD来进行服务的测试与部署

  - 开发人员可以专注于服务本身的业务编写

    

- 服务的技术多样性

  - 服务使用的技术可以由开发团队自身决定，不需要强制使用特定语言等






## 在项目中使用微服务

​	我认为，项目中使用微服务也有一套框架，即微服务使用的核心组件

- **服务描述**

  - 服务描述主要是提供该服务对应的信息，例如服务的功能和服务返回的结果

  - 使用接口文档来对服务暴露的API进行相关描述，也可以查看团队对服务自身编写的描述文档

    

- **注册中心(服务发现)**

  - 服务需要被外部服务调用时，外部服务需要知道该服务的地址，因此服务需要将IP地址(IP+端口号)注册到注册中心；注册后外部服务可以从注册中心查询需要调用的服务的地址，紧接着发起请求

  - 注册中心可以当作是一个中介的形象，客户(消费者)通过注册中心找到服务本身，且注册中心中的服务在变化（新增服务或服务宕机）需要将其主动通知给服务消费者

    ![](https://raw.githubusercontent.com/zyb-992/Photobed/master/zyb/202304160233083.png)



- **链路追踪**

  - 在日志中需要记录从上游到下游，请求调用经过的每个服务，使得在请求出错时查询日志方便定位问题所在
  - 主要方法
    - 请求产生时，程序会创建一个全局id贯穿上游到下游服务，这个id作为链路调用中的唯一标识，将请求依赖的服务串联起来，这个标识会成为某次请求中服务日志输出的一部分
    
      ![](https://raw.githubusercontent.com/zyb-992/Photobed/master/zyb/202304160233530.png)
    
      ​																								[图源](https://research.google/pubs/pub36356/)





- **监控服务**

  - 由于应用被服务化拆分，请求会调用多个服务，在请求过程中就需要对每个服务进行监控；还需要监控各个服务器的基本情况
    - 对服务监控：监控服务接口的响应时间，还有接口某时间段内的请求数(QPS)等
    - 服务器监控：监控服务器的健康状况，如服务器是否存活，IO，网络带宽，内存使用量等
  - 使用监控平台，在服务中服务可以自主上报数据到监控平台，监控平台通过数据采集后将数据回传到客户端图形化界面进行展示

    <img src="https://raw.githubusercontent.com/zyb-992/Photobed/master/zyb/202304160233889.png" style="zoom:67%;" />
    
    

- **编写测试**

  - 在我看来，为服务编写测试是非常必要的；首先要保证服务实现的功能符合预期，进行相应的功能测试，以及在不同的情况下测试也应该得到相同结果；同时避免引用其他服务，服务的测试数据可以提前预设，即**打桩**；然后服务在测试环境中进行性能测试，测试在高负载下服务的运行情况

  - 现在的测试流程已经实现自动化，如同书上说的，一次完整的测试过程：在**持续交付**中使用流水线构建完整的流程，将更新后的代码使用版本控制工具上传至代码库，系统触发构建过程，将代码构建编译，进行测试，最后确认满足条件后服务上线发布到生产环境

    ![](https://raw.githubusercontent.com/zyb-992/Photobed/master/zyb/202304160233726.png)



## 微服务存在的问题

​	从开发人员的角度看，微服务的问题也不少，例如：

- *单体架构，怎样的代码库才算大？才需要演化成微服务？*
- *使用微服务以后，各个服务之间的边界如何确定？*
- *如何将单体应用的代码库拆分为相应合适的服务？*
- *怎样确定服务的技术选型？*
- *如何保证开发团队的开发思想？*
- *微服务上线以后，当服务的数量越来越多，部分服务的利用率较低，造成服务器资源浪费，如何解决？*

​	大部分问题需要架构师来协助解决，在动手拆解前需要与开发团队进行研讨，确定了各团队的职责与项目架构、技术选型以后再由各团队进行相关工作





## 对于微服务的认识

​	作为一名准后端开发人员，从个人的角度认为学习Docker和Kubernetes是使用微服务必要的一个过程；都说现在是云原生时代，通过容器化，能够加快程序的部署过程以及使用云平台来构建某些基础设施，降本增效；Kubernetes是使用Go编写的，有一定的云基础后，可以在实践过程中基于源码来进行二次开发，以达目的；与此同时，微服务的核心组件中也使用到了Go开发的一些工具，例如服务发现中使用的Etcd、Consul，以及管理服务的工具Istio等；学习Go是我认为对微服务中使用这些工具的一个很大的优势



​	如今，使用微服务架构时，每个服务通常会被打包为一个`Docker`镜像，根据Docker官方的建议，**每个容器最好只运行一个独立的应用**，因此每个容器单独运行一个服务，在`Dockfile`或命令行中使用*EXPOSE*来暴露服务的API端口，服务间通过Docker进行网络通信；同时为了保证服务的高可用以及服务的扩展，可以使用`Kubernetes`等容器编排工具来实现



​	`Kubernetes`通过使用yaml创建**`Deployment`**，`Deployment`可以理解为`Pod`控制器，自动创建并管理`Pod`副本，而`Pod`是一个逻辑上的概念，它在工作节点上是一个独立的环境，通常一个`Pod`中只负责一个容器运行，多个容器也可以在`Pod`中运行，但多个容器中主要是一个容器为主进程，而其他的容器只是辅助主进程运行，所有在同个`Pod`中的容器共享网络空间和数据；`Kubernetes`通过存活探针来探测`Pod`当前的状态，当`Pod`中容器发生故障时，导致`Pod`不能正常运行，此时`Deployment`作为管理`Pod`副本的集合，会重新创建一个`Pod`副本来代替它；因此我们可以通过创建`Deployment`实现服务的高可用



​	在服务中我们可以通过配置文件或者在注册中心中查询到目标服务，但服务现在在容器中运行，而容器又在`Pod`中运行，`Pod`在`Kubernetes`中是动态创建的，即使用的是动态IP，因此每次创建`Pod`的IP都不一致，那么外部客户端在输入请求访问时，如何寻找到请求需要的服务呢？这就需要用到`Kubernetes`中的**`Service`**了，在yaml中创建`Service`，同时指定了需要绑定的`Pod`的标签（创建`Pod`时指定`metadata`中的`Label`），且`Service`是静态IP；因此当`Service`创建以后，每个`Service`就对应同个标签的Pod集合，在请求调用服务时，`Service`得到请求需要访问的IP地址，然后将其路由到被需要的Pod上进行	

​	关于微服务的学习，不止于`Docker`和`K8s`，还有许多值得学习的技术，它们是我觉得在作为Go开发上比较重要的点；简单来讲，微服务就是各个服务之间通过通信共同协作，但要深入其中也有不少的门道，还是需要有很深的内功才能将服务做到标准化；我也坚信一个观点：*理论学习的再多，也需要自己动手实践*，因此在学习理论知识的同时也要多实践，才能对其有更深刻的印象

​	

 
